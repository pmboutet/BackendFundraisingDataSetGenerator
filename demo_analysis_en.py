#!/usr/bin/env python
"""
Analysis script to demonstrate complex correlation:
Wealth + Digital Channel + Longevity = Strong correlation with regular donors

This script analyzes generated data and calculates:
- Regular donor rate by wealth category
- Regular donor rate by channel (Digital vs Non-Digital)
- Regular donor rate by donor longevity
- Combined correlation: Wealth + Digital + Longevity
- Visualizations to illustrate the complex correlation
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import zipfile
import io
import sys
import os
from pathlib import Path
from datetime import datetime

# Configure plots
try:
    plt.style.use('seaborn-v0_8-darkgrid')
except OSError:
    try:
        plt.style.use('seaborn-darkgrid')
    except OSError:
        plt.style.use('default')
sns.set_palette("husl")

def load_data_from_zip(zip_path):
    """Load data from ZIP file generated by API"""
    transactions_df = None
    contacts_df = None
    
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        for file_name in zip_ref.namelist():
            if 'transactions' in file_name.lower():
                with zip_ref.open(file_name) as f:
                    transactions_df = pd.read_csv(f)
            elif 'contacts' in file_name.lower():
                with zip_ref.open(file_name) as f:
                    contacts_df = pd.read_csv(f)
    
    return transactions_df, contacts_df

def load_data_from_csv(transactions_path, contacts_path):
    """Load data from CSV files"""
    transactions_df = pd.read_csv(transactions_path)
    contacts_df = pd.read_csv(contacts_path)
    return transactions_df, contacts_df

def identify_regular_donors(transactions_df, min_donations=3):
    """
    Identify regular donors based on number of donations.
    
    Args:
        transactions_df: DataFrame of transactions
        min_donations: Minimum number of donations to be considered regular
    
    Returns:
        DataFrame with statistics per contact
    """
    donor_stats = transactions_df.groupby('contact_id').agg({
        'donation_amount': ['count', 'sum', 'mean'],
        'date': 'min',
        'channel': lambda x: x.mode()[0] if len(x.mode()) > 0 else x.iloc[0]  # Most used channel
    }).reset_index()
    
    donor_stats.columns = ['contact_id', 'nb_donations', 'total_donated', 'avg_donation', 'first_donation', 'primary_channel']
    
    # Identify regular donors
    donor_stats['is_regular'] = donor_stats['nb_donations'] >= min_donations
    
    return donor_stats

def calculate_donor_longevity(contacts_df, transactions_df, current_year=2025):
    """
    Calculate how long each donor has been active.
    
    Returns:
        Series with longevity in years per contact_id
    """
    first_donations = transactions_df.groupby('contact_id')['date'].min()
    first_donations = pd.to_datetime(first_donations)
    
    longevity = (pd.Timestamp(f'{current_year}-01-01') - first_donations).dt.days / 365.25
    
    return longevity

def analyze_complex_correlation(transactions_df, contacts_df, min_donations=3):
    """
    Analyze complex correlation: Wealth + Digital Channel + Longevity
    
    Returns:
        dict: Analysis results
    """
    # Identify regular donors
    donor_stats = identify_regular_donors(transactions_df, min_donations)
    
    # Merge with contact data
    analysis_df = donor_stats.merge(contacts_df, on='contact_id', how='left')
    
    # Calculate longevity
    longevity = calculate_donor_longevity(contacts_df, transactions_df)
    analysis_df['longevity_years'] = analysis_df['contact_id'].map(longevity)
    
    # Categorize jobs
    wealthy_jobs = [
        "CEO", "Director", "Surgeon", "Lawyer", "Investment Banker",
        "Consultant", "Senior Engineer", "Architect", "Specialist Doctor", "Executive",
        "IT Director", "Financial Advisor", "Marketing Director", "Operations Manager", "Research Director"
    ]
    
    analysis_df['job_category'] = analysis_df['job'].apply(
        lambda x: 'Wealthy' if x in wealthy_jobs else 'Non-Wealthy'
    )
    
    # Categorize wealth by decile
    analysis_df['wealth_category'] = analysis_df['origin_decile'].apply(
        lambda x: 'High Wealth' if x >= 8 else ('Medium Wealth' if x >= 5 else 'Low Wealth')
    )
    
    # Categorize channel (Digital = Online, Email, MonthlyGiving; Non-Digital = others)
    digital_channels = ['Online', 'Email', 'MonthlyGiving']
    analysis_df['channel_type'] = analysis_df['primary_channel'].apply(
        lambda x: 'Digital' if x in digital_channels else 'Non-Digital'
    )
    
    # Categorize longevity
    analysis_df['longevity_category'] = pd.cut(
        analysis_df['longevity_years'],
        bins=[0, 1, 3, 10],
        labels=['New (<1 year)', 'Medium (1-3 years)', 'Long-term (3+ years)'],
        include_lowest=True
    )
    
    # Create combined category
    analysis_df['combined_category'] = (
        analysis_df['wealth_category'] + ' + ' +
        analysis_df['channel_type'] + ' + ' +
        analysis_df['longevity_category'].astype(str)
    )
    
    # Calculate statistics
    results = {
        'total_donors': len(analysis_df),
        'regular_donors': analysis_df['is_regular'].sum(),
        'one_time_donors': (~analysis_df['is_regular']).sum(),
        'regular_rate_overall': analysis_df['is_regular'].mean() * 100,
    }
    
    # Statistics by individual factors
    results['by_wealth'] = analysis_df.groupby('wealth_category')['is_regular'].agg(['sum', 'count', 'mean'])
    results['by_channel'] = analysis_df.groupby('channel_type')['is_regular'].agg(['sum', 'count', 'mean'])
    results['by_longevity'] = analysis_df.groupby('longevity_category', observed=True)['is_regular'].agg(['sum', 'count', 'mean'])
    
    # Statistics by combined factors
    combined_stats = analysis_df.groupby('combined_category').agg({
        'is_regular': ['sum', 'count', 'mean'],
        'nb_donations': 'mean',
        'total_donated': 'mean',
        'avg_donation': 'mean'
    })
    results['by_combined'] = combined_stats
    
    # Key combination: High Wealth + Digital + Long-term
    key_combination = 'High Wealth + Digital + Long-term (3+ years)'
    if key_combination in combined_stats.index:
        key_rate = combined_stats.loc[key_combination, ('is_regular', 'mean')] * 100
        results['key_combination_rate'] = key_rate
    else:
        results['key_combination_rate'] = 0
    
    # Calculate correlation coefficients
    results['wealth_correlation'] = analysis_df[['origin_decile', 'nb_donations']].corr().iloc[0, 1]
    results['longevity_correlation'] = analysis_df[['longevity_years', 'nb_donations']].corr().iloc[0, 1]
    
    return results, analysis_df

def create_visualizations(analysis_df, output_dir='demo_output'):
    """Create visualizations for complex correlation"""
    os.makedirs(output_dir, exist_ok=True)
    
    # Create comprehensive figure
    fig = plt.figure(figsize=(18, 12))
    gs = fig.add_gridspec(3, 3, hspace=0.3, wspace=0.3)
    
    # 1. Regular donor rate by wealth category
    ax1 = fig.add_subplot(gs[0, 0])
    wealth_stats = analysis_df.groupby('wealth_category')['is_regular'].agg(['sum', 'count'])
    wealth_stats['rate'] = (wealth_stats['sum'] / wealth_stats['count']) * 100
    ax1.bar(wealth_stats.index, wealth_stats['rate'], color=['#e74c3c', '#f39c12', '#2ecc71'], alpha=0.7)
    ax1.set_title('Regular Donor Rate by Wealth Category', fontsize=12, fontweight='bold')
    ax1.set_ylabel('Percentage (%)')
    ax1.set_ylim(0, max(wealth_stats['rate']) * 1.2)
    for i, v in enumerate(wealth_stats['rate']):
        ax1.text(i, v + 1, f'{v:.1f}%', ha='center', fontweight='bold')
    
    # 2. Regular donor rate by channel type
    ax2 = fig.add_subplot(gs[0, 1])
    channel_stats = analysis_df.groupby('channel_type')['is_regular'].agg(['sum', 'count'])
    channel_stats['rate'] = (channel_stats['sum'] / channel_stats['count']) * 100
    ax2.bar(channel_stats.index, channel_stats['rate'], color=['#3498db', '#95a5a6'], alpha=0.7)
    ax2.set_title('Regular Donor Rate by Channel Type', fontsize=12, fontweight='bold')
    ax2.set_ylabel('Percentage (%)')
    ax2.set_ylim(0, max(channel_stats['rate']) * 1.2)
    for i, v in enumerate(channel_stats['rate']):
        ax2.text(i, v + 1, f'{v:.1f}%', ha='center', fontweight='bold')
    
    # 3. Regular donor rate by longevity
    ax3 = fig.add_subplot(gs[0, 2])
    longevity_stats = analysis_df.groupby('longevity_category', observed=True)['is_regular'].agg(['sum', 'count'])
    longevity_stats['rate'] = (longevity_stats['sum'] / longevity_stats['count']) * 100
    ax3.bar(range(len(longevity_stats)), longevity_stats['rate'], 
            color=['#e74c3c', '#f39c12', '#2ecc71'], alpha=0.7)
    ax3.set_xticks(range(len(longevity_stats)))
    ax3.set_xticklabels(longevity_stats.index, rotation=15, ha='right')
    ax3.set_title('Regular Donor Rate by Donor Longevity', fontsize=12, fontweight='bold')
    ax3.set_ylabel('Percentage (%)')
    ax3.set_ylim(0, max(longevity_stats['rate']) * 1.2)
    for i, v in enumerate(longevity_stats['rate']):
        ax3.text(i, v + 1, f'{v:.1f}%', ha='center', fontweight='bold')
    
    # 4. Combined factors - Heatmap
    ax4 = fig.add_subplot(gs[1, :])
    # Create pivot table for heatmap
    pivot_data = analysis_df.groupby(['wealth_category', 'channel_type', 'longevity_category'], observed=True)['is_regular'].mean().unstack(level=[1, 2])
    if pivot_data.empty:
        # Fallback: simpler pivot
        pivot_data = analysis_df.groupby(['wealth_category', 'channel_type'])['is_regular'].mean().unstack()
    sns.heatmap(pivot_data * 100, annot=True, fmt='.1f', cmap='YlOrRd', ax=ax4, cbar_kws={'label': 'Regular Donor Rate (%)'})
    ax4.set_title('Regular Donor Rate: Wealth √ó Channel √ó Longevity', fontsize=12, fontweight='bold')
    ax4.set_xlabel('Channel + Longevity')
    ax4.set_ylabel('Wealth Category')
    
    # 5. Key combinations comparison
    ax5 = fig.add_subplot(gs[2, :])
    combined_stats = analysis_df.groupby('combined_category')['is_regular'].agg(['sum', 'count', 'mean'])
    combined_stats['rate'] = combined_stats['mean'] * 100
    combined_stats = combined_stats.sort_values('rate', ascending=False).head(10)
    
    colors = ['#2ecc71' if 'High Wealth + Digital + Long-term' in idx else '#95a5a6' for idx in combined_stats.index]
    ax5.barh(range(len(combined_stats)), combined_stats['rate'], color=colors, alpha=0.7)
    ax5.set_yticks(range(len(combined_stats)))
    ax5.set_yticklabels(combined_stats.index, fontsize=9)
    ax5.set_xlabel('Regular Donor Rate (%)', fontsize=11)
    ax5.set_title('Top 10 Combinations: Regular Donor Rate', fontsize=12, fontweight='bold')
    ax5.invert_yaxis()
    for i, v in enumerate(combined_stats['rate']):
        ax5.text(v + 0.5, i, f'{v:.1f}%', va='center', fontweight='bold')
    
    plt.suptitle('Complex Correlation Analysis: Wealth + Digital Channel + Longevity', 
                 fontsize=16, fontweight='bold', y=0.995)
    plt.savefig(f'{output_dir}/complex_correlation_analysis.png', dpi=300, bbox_inches='tight')
    print(f"‚úì Complex correlation graphs saved to {output_dir}/complex_correlation_analysis.png")
    
    # Additional scatter plot: Longevity vs Donations by Wealth and Channel
    fig2, ax = plt.subplots(figsize=(12, 8))
    
    for wealth_cat in ['Low Wealth', 'Medium Wealth', 'High Wealth']:
        for channel_type in ['Digital', 'Non-Digital']:
            subset = analysis_df[
                (analysis_df['wealth_category'] == wealth_cat) & 
                (analysis_df['channel_type'] == channel_type)
            ]
            if len(subset) > 0:
                ax.scatter(subset['longevity_years'], subset['nb_donations'],
                          label=f'{wealth_cat} + {channel_type}',
                          alpha=0.6, s=50)
    
    ax.set_xlabel('Donor Longevity (years)', fontsize=12)
    ax.set_ylabel('Number of Donations', fontsize=12)
    ax.set_title('Donations vs Longevity by Wealth and Channel', fontsize=14, fontweight='bold')
    ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    ax.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(f'{output_dir}/scatter_complex_correlation.png', dpi=300, bbox_inches='tight')
    print(f"‚úì Scatter plot saved to {output_dir}/scatter_complex_correlation.png")
    
    plt.close('all')

def print_analysis_report(results, analysis_df):
    """Print detailed analysis report"""
    print("\n" + "="*90)
    print("COMPLEX CORRELATION ANALYSIS: WEALTH + DIGITAL CHANNEL + LONGEVITY")
    print("="*90 + "\n")
    
    print(f"üìä OVERALL STATISTICS")
    print(f"   ‚Ä¢ Total donors: {results['total_donors']:,}")
    print(f"   ‚Ä¢ Regular donors (‚â•3 donations): {results['regular_donors']:,}")
    print(f"   ‚Ä¢ One-time donors: {results['one_time_donors']:,}")
    print(f"   ‚Ä¢ Overall regular donor rate: {results['regular_rate_overall']:.2f}%\n")
    
    print(f"üíº BY WEALTH CATEGORY")
    print("-" * 90)
    by_wealth = results['by_wealth']
    for category in by_wealth.index:
        regular_count = int(by_wealth.loc[category, 'sum'])
        total_count = int(by_wealth.loc[category, 'count'])
        rate = by_wealth.loc[category, 'mean'] * 100
        print(f"   {category:20s}: {regular_count:5d} / {total_count:6d} ({rate:5.2f}%)")
    
    print(f"\nüì± BY CHANNEL TYPE")
    print("-" * 90)
    by_channel = results['by_channel']
    for channel in by_channel.index:
        regular_count = int(by_channel.loc[channel, 'sum'])
        total_count = int(by_channel.loc[channel, 'count'])
        rate = by_channel.loc[channel, 'mean'] * 100
        print(f"   {channel:20s}: {regular_count:5d} / {total_count:6d} ({rate:5.2f}%)")
    
    print(f"\n‚è±Ô∏è  BY DONOR LONGEVITY")
    print("-" * 90)
    by_longevity = results['by_longevity']
    for longevity in by_longevity.index:
        regular_count = int(by_longevity.loc[longevity, 'sum'])
        total_count = int(by_longevity.loc[longevity, 'count'])
        rate = by_longevity.loc[longevity, 'mean'] * 100
        print(f"   {str(longevity):20s}: {regular_count:5d} / {total_count:6d} ({rate:5.2f}%)")
    
    print(f"\nüîó COMBINED FACTORS - KEY COMBINATIONS")
    print("-" * 90)
    combined_stats = results['by_combined']
    top_combinations = combined_stats.sort_values(('is_regular', 'mean'), ascending=False).head(8)
    
    print(f"   {'Combination':<60} | Rate (%) | Avg Donations")
    print(f"   {'-'*60} | {'-'*9} | {'-'*13}")
    for idx, row in top_combinations.iterrows():
        rate = row[('is_regular', 'mean')] * 100
        avg_donations = row[('nb_donations', 'mean')]
        print(f"   {str(idx):<60} | {rate:7.2f}% | {avg_donations:11.2f}")
    
    print(f"\nüéØ KEY FINDING")
    print("-" * 90)
    key_rate = results['key_combination_rate']
    overall_rate = results['regular_rate_overall']
    multiplier = key_rate / overall_rate if overall_rate > 0 else 0
    
    print(f"   High Wealth + Digital + Long-term (3+ years): {key_rate:.2f}%")
    print(f"   Overall regular donor rate: {overall_rate:.2f}%")
    print(f"   Multiplier: {multiplier:.1f}x higher than average")
    
    if key_rate > overall_rate * 2:
        print(f"   ‚úì STRONG CORRELATION DEMONSTRATED")
    elif key_rate > overall_rate * 1.5:
        print(f"   ‚úì Moderate correlation demonstrated")
    else:
        print(f"   ‚ö† Weak correlation")
    
    print(f"\nüìà CORRELATION COEFFICIENTS")
    print("-" * 90)
    print(f"   Wealth (decile) ‚Üî Number of donations: {results['wealth_correlation']:.4f}")
    print(f"   Longevity (years) ‚Üî Number of donations: {results['longevity_correlation']:.4f}")
    
    print("\n" + "="*90 + "\n")

def main():
    """Main function"""
    if len(sys.argv) < 2:
        print("Usage: python demo_analysis_en.py <zip_file> [min_donations] [timestamp]")
        print("   or: python demo_analysis_en.py <transactions.csv> <contacts.csv> [min_donations] [timestamp]")
        sys.exit(1)
    
    # Determine output directory from timestamp or extract from zip filename
    output_dir = 'demo_output'
    timestamp = None
    
    if len(sys.argv) > 3:
        # Timestamp provided as argument
        timestamp = sys.argv[3]
        output_dir = os.path.join('demo_output', timestamp)
    elif sys.argv[1].endswith('.zip'):
        # Try to extract timestamp from zip filename
        zip_path = sys.argv[1]
        # Check if it's a symlink and resolve it
        if os.path.islink(zip_path):
            zip_path = os.readlink(zip_path)
        # Extract timestamp from path like demo_output/20241118_123456/demo_data_en_20241118_123456.zip
        import re
        match = re.search(r'(\d{8}_\d{6})', zip_path)
        if match:
            timestamp = match.group(1)
            output_dir = os.path.join('demo_output', timestamp)
        else:
            # Fallback: use current timestamp
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_dir = os.path.join('demo_output', timestamp)
    else:
        # Use current timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_dir = os.path.join('demo_output', timestamp)
    
    os.makedirs(output_dir, exist_ok=True)
    print(f"üìÅ Output directory: {output_dir}")
    
    min_donations = int(sys.argv[2]) if len(sys.argv) > 2 and sys.argv[2].isdigit() else 3
    
    # Load data
    print("üì• Loading data...")
    if sys.argv[1].endswith('.zip'):
        transactions_df, contacts_df = load_data_from_zip(sys.argv[1])
    else:
        transactions_df, contacts_df = load_data_from_csv(sys.argv[1], sys.argv[2])
        min_donations = int(sys.argv[3]) if len(sys.argv) > 3 and sys.argv[3].isdigit() else 3
    
    print(f"   ‚Ä¢ {len(transactions_df):,} transactions loaded")
    print(f"   ‚Ä¢ {len(contacts_df):,} contacts loaded")
    
    # Analyze
    print("\nüîç Analyzing complex correlation...")
    results, analysis_df = analyze_complex_correlation(transactions_df, contacts_df, min_donations)
    
    # Print report
    print_analysis_report(results, analysis_df)
    
    # Create visualizations
    print("üìä Creating visualizations...")
    create_visualizations(analysis_df, output_dir)
    
    # Save analysis data
    print("\nüíæ Saving analysis data...")
    
    # Save with Salesforce NPC format
    from fundraising_generator.services.salesforce_mapper import export_to_salesforce_format
    analysis_df_sf = export_to_salesforce_format(analysis_df, data_type='analysis')
    analysis_df_sf.to_csv(os.path.join(output_dir, 'complex_analysis_data_salesforce.csv'), index=False)
    print(f"   ‚úì Data saved to {output_dir}/complex_analysis_data_salesforce.csv (Salesforce NPC format)")
    
    # Also save original format for backward compatibility
    analysis_df.to_csv(os.path.join(output_dir, 'complex_analysis_data.csv'), index=False)
    print(f"   ‚úì Data saved to {output_dir}/complex_analysis_data.csv (original format)")
    
    # Save raw transactions (one row per transaction) in Salesforce NPC format
    print("\nüíæ Saving raw transactions data...")
    transactions_sf = export_to_salesforce_format(transactions_df, data_type='transactions')
    transactions_sf.to_csv(os.path.join(output_dir, 'Gift_Transaction_Raw_Salesforce.csv'), index=False)
    print(f"   ‚úì Raw transactions saved to {output_dir}/Gift_Transaction_Raw_Salesforce.csv (Salesforce NPC format)")
    print(f"   ‚Ä¢ {len(transactions_sf):,} transactions (one row per transaction)")
    
    # Also save raw transactions in original format for backward compatibility
    transactions_df.to_csv(os.path.join(output_dir, 'transactions_raw.csv'), index=False)
    print(f"   ‚úì Raw transactions saved to {output_dir}/transactions_raw.csv (original format)")
    
    print("\n‚úÖ Analysis complete!")

if __name__ == '__main__':
    main()

